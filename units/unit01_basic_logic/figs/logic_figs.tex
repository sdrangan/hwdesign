\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{amsmath, amssymb, bm, cite, epsfig, psfrag}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{pgf,tikz}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{../../styles/course}


\begin{document}

\title{Introduction to Hardware Design\\
Basic Digital Logic:  Figures and Code Snippets}
\author{Profs. Sundeep Rangan, Siddharth Garg}
\date{}

\maketitle
\subsection{Combinational Example: ReLU with a linear input}

We consider implementing the ReLU function:
  \[
    y = \max\{ ax + b, 0\}
  \]
  where $x$, $a$, and $b$ are integer inputs.  This function arises commonly
  in machine learning.
  We first consider a purely combinational implementation of this function.
  A possible SystemVerilog implementation is as follows:

\begin{systemverilogcode}
    module relu_lin (
      input logic int x,
      input logic int a,
      input logic int b,
      output logic int y
    );
      always_comb begin
        logic int mult_out, add_out;
        mult_out = x * a;
        add_out = mult_out + b;
        y = (add_out > 0) ? add_out : 0;
      end
    endmodule
  \end{systemverilogcode}

  When this module is synthesized, a potential block diagram is as shown in
  Figure~\ref{fig:relu_comb}.

  
\begin{figure}
\centering

  \begin{tikzpicture}[node distance=1cm]

    % x, a and multipliers
    \node (x) {\texttt{x}};
    \node [circop, right=1cm of x,fill=green!20] (mul) {$\times$};
    \node [above of=mul, yshift=0.5cm] (a) {\texttt{a}};
    \draw[->] (x) -- (mul);
    \draw[->] (a) -- (mul);

    % b and adder
    \node[circop,right=2cm of mul,fill=green!20] (add) {$+$};
    \node [above of=add, yshift=0.5cm] (b) {\texttt{b}};
    \draw[->] (mul) -- node[midway,above] {\texttt{mult\_out}} (add);
    \draw[->] (b) -- (add);

    % max block
    \node[draw, right=2cm of add,minimum height=1cm,fill=green!10] (max) {$\max\{u,0\}$};
    \draw[->] (add) -- node[midway,above] {\texttt{add\_out}} (max);
    \draw[->] (max) -- ++(1.5,0) node[right] {\texttt{y}};
\end{tikzpicture}
  \caption{Fully combinational block diagram for ReLU with a linear input.}
  \label{fig:relu_comb}
\end{figure}


\subsection{Adder}

Implementation of $y = a + b + c + d$.  First, we show a serial implementation:

\begin{figure}
\centering

  \begin{tikzpicture}[font=\scriptsize, node distance=1cm]

    \node (a) {\texttt{a}};
    \node [circop, right=1cm of a, fill=blue!20] (add1) {$+$};
    \node [above of=add1, yshift=0.5cm] (b) {\texttt{b}};
    \draw[->] (a) -- (add1);
    \draw[->] (b) -- (add1);
    \node [circop, right=1cm of add1, fill=blue!20] (add2) {$+$};
    \node [above of=add2, yshift=0.5cm] (c) {\texttt{c}};
    \draw[->] (add1) -- (add2);
    \draw[->] (c) -- (add2);
    \node [circop, right=1cm of add2, fill=blue!20] (add3) {$+$};
    \node [above of=add3, yshift=0.5cm] (d) {\texttt{d}};
    \draw[->] (add2) -- (add3);
    \draw[->] (d) -- (add3);
    \node (y) [right=1cm of add3] {\texttt{y}};
    \draw[->] (add3) -- (y);
  
\end{tikzpicture}
  \caption{Serial implementation of an adder.}
  \label{fig:adder_serial}
\end{figure}

Next, we show a parallel implementation:
\begin{align*}
  z_1 = a + b \\
  z_2 = c + d \\
  y = z_1 + z_2
\end{align*}


\begin{figure}
\centering

  \begin{tikzpicture}[node distance=1cm]

    \node (a) {\texttt{a}};
    \node[draw, right=1cm of a, minimum height=1.5cm,
      minimum width=1.5cm, fill=red!10,align=center] (f1) {$F_1$\\\SI{3}{ns}};
    \node[draw, right=1cm of f1,minimum height=1.5cm,
      minimum width=1.5cm,fill=red!10,align=center] (f2) {$F_2$\\ \SI{2}{ns}};
    \node (b) [below=2cm of a] {\texttt{b}};
    \node[draw, right=1cm of b,minimum height=1.5cm,minimum width=1.5cm,
      fill=green!10,align=center] (f3) {$F_3$\\ \SI{3.5}{ns}};
    \node[draw, right=1cm of f3,minimum height=1.5cm,minimum width=1.5cm,
      fill=green!10,align=center] (f4) {$F_4$\\ \SI{2.5}{ns}};
    \draw[->,ultra thick, red] (a) -- (f1);
    \draw[->,ultra thick, red] (f1) -- (f2);
    \draw[->,ultra thick, red] (f2) -- (f4);
    \draw[->,thick, green] (b) -- (f3);
    \draw[->,thick, green] (f3) -- (f4);
    \node (y) [right=1cm of f4] {\texttt{y}};
    \draw[->,ultra thick, red] (f4) -- (y);

  
\end{tikzpicture}
  \caption{Critical path of a circuit.  Critical path highlighted in red.}
  \label{fig:crit_path}
\end{figure}




\begin{figure}
\centering

  \begin{tikzpicture}[font=\scriptsize, node distance=1cm]

    \node (a) {\texttt{a}};
    \node [circop, right=1cm of a, fill=blue!20] (add1a) {$+$};
    \node [above of=add1a, yshift=0.5cm] (b) {\texttt{b}};
    \draw[->] (a) -- (add1a);
    \draw[->] (b) -- (add1a);

    \node (c) [below=2cm of a] {\texttt{c}};
    \node [circop, right=1cm of c, fill=blue!20] (add1b) {$+$};
    \node [below of=add1b, yshift=-0.5cm] (d) {\texttt{d}};
    \draw[->] (c) -- (add1b);
    \draw[->] (d) -- (add1b);

    \node [circop, right=2cm of add1a, yshift=-1.3cm, fill=blue!20] (add2) {$+$};
    \draw[->] (add1a) -| (add2);
    \draw[->] (add1b) -| (add2);
    \node (y) [right=1cm of add2] {\texttt{y}};
    \draw[->] (add2) -- (y);
  
\end{tikzpicture}
  \caption{Parallel implementation of an adder.}
  \label{fig:tree}
\end{figure}

\subsection{Register}

Draw a basic register.


\begin{figure}
\begin{tikzpicture}[>=stealth, font=\scriptsize, node distance=1.8cm]

  % Register 
  \node[shape=register, draw, minimum width=1cm, minimum height=2cm,
        fill=blue!10] (reg) {};

  % Input, clock and output
  \node [left=1cm of reg.input] (x) {\texttt{x}};
  \node [left=1cm of reg.clk] (clk) {\texttt{clk}};
  \draw[->] (x) -- (reg.input);
  \draw[->] (clk) -- (reg.clk);

  \node [right=1cm of reg.output] (xreg) {\texttt{xreg}};
  \draw[->] (reg.output) -- (xreg);
\end{tikzpicture}
  \caption{Basic register block diagram.}
  \label{fig:reg}
  
\end{figure}

\subsection{Sequential ReLU with a linear input}

The sequential implementation of the ReLU with a linear input is as follows:


\begin{systemverilogcode}
    module relu_lin (
      input logic clk,
      input logic rst_n,
      input logic int x,
      input logic int a,
      input logic int b,
      output logic int y
    );
      int x_reg, a_reg, b_reg;

      always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
          x_reg <= 0;
          a_reg <= 0;
          b_reg <= 0;
        end else begin
          x_reg <= x;
          a_reg <= a;
          b_reg <= b;
        end
      end
      always_comb begin
        logic int mult_out, add_out;
        mult_out = x_reg * a_reg;
        add_out = mult_out + b_reg;
        y = (add_out > 0) ? add_out : 0;
      end
    endmodule
  \end{systemverilogcode}

 
\begin{figure}
\centering

  \begin{tikzpicture}[font=\scriptsize, node distance=1cm]

    % x and multipliers
    \node (x) {\texttt{x}};
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        right=1cm of x,fill=blue!10] (xreg) {};
    \node [circop, right=1cm of xreg,fill=green!20] (mul) {$\times$};
    \draw[->] (x) -- (xreg.input);
    \draw[->] (xreg.output) -- node[midway,above] {\texttt{xreg}} (mul);


    % a and areg
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        above=0.7cm of mul,xshift=-0.5cm,fill=blue!10] (areg) {};
    \node[left=0.5cm of areg] (a) {\texttt{a}};
    \draw[->] (a) -- (areg.input);
    \draw[->] (areg.output) -| node [midway,right,xshift=0cm,yshift=-0.3cm] 
      {\texttt{areg}} (mul);


    % adder
    \node[circop,right=2.5cm of mul,fill=green!20] (add) {$+$};
    \draw[->] (mul) -- node[midway,above] {\texttt{mult\_out}} (add);

    % b and breg
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        above=0.7cm of add,xshift=-0.5cm,fill=blue!10] (breg) {};
    \node[left=0.5cm of breg] (b) {\texttt{b}};
    \draw[->] (b) -- (breg);
    \draw[->] (breg.output) -| node [midway,right,xshift=0cm,yshift=-0.3cm] 
      {\texttt{breg}} (add);

    % max block
    \node[draw, right=2cm of add,minimum height=1cm,fill=green!10] (max) {$\max\{u,0\}$};
    \draw[->] (add) -- node[midway,above] {\texttt{add\_out}} (max);
    \draw[->] (max) -- ++(1.5,0) node[right] {\texttt{y}};
\end{tikzpicture}
  \caption{Synchronous version of ReLU with a linear input.}
  \label{fig:relu_sync}
\end{figure}


\subsection{Quadratic Function with a Single Cycle}
We wish to implement the function:
\[
  y = w_2 x^2  + w_1 x + w_0
\]

A single cycle implementation is as follows treating $w_i$ as fixed parameters is:
\begin{systemverilogcode}
module quad_func #(
  parameter int w2 = 0, 
  parameter int w1 = 0, 
  parameter int w0 = 0
) (
  input logic clk,
  input logic int x,
  output logic int y
);
  int xreg;
  always_ff @(posedge clk) begin
    xreg <= x;
  end
  always_comb begin
    logic int xsq, xsq_w2, x_w1;
    xsq = xreg * xreg;
    xsq_w2 = w2 * xsq;
    x_w1 = w1 * xreg;
    y = xsq_w2 + x_w1 + w0;
  end
\end{systemverilogcode}

The block diagram is as shown in Figure~\ref{fig:quad_func}.

\begin{figure}
\centering
\begin{tikzpicture}
    % Input register
    \node (x) {\texttt{x}};
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        right=1cm of x,fill=blue!10] (xreg) {};
    \draw[->] (x) -- (xreg.input);
    \draw[-] (xreg.output) -- ++(1.3,0) node [midway,above] {\texttt{x\_reg}}
      coordinate (xreg_split);
    \fill (xreg_split) circle (1.5pt);

    % Multiplier for x^2
    \node [circop, right=0.8cm of xreg_split,fill=green!20] (mul1) {$\times$};
    \draw[->] (xreg_split) -- (mul1);
    \draw[->] (xreg_split) -- ++(0,0.5) -| (mul1);
    
    % Multiplier for w2*x^2
    \node [circop, right=1cm of mul1,fill=green!20] (mul2) {$\times$};
    \node [above of=mul2, yshift=0.5cm] (w2) {\texttt{w2}};
    \draw[->] (mul1) -- (mul2);
    \draw[->] (w2) -- (mul2);

    % Multiplier for w1*x
    \node [circop, below=1cm of mul2,fill=green!20] (mul3) {$\times$};
    \node [below=1cm of mul3] (w1) {\texttt{w1}};
    \draw[->] (xreg_split) |- (mul3);
    \draw[->] (w1) -- (mul3);

    % Adder w2*x^2 + w1*x   
    \node[circop,right=1.3cm of mul2,fill=green!20] (add1) {$+$};
    \draw[->] (mul2) -- node[midway,above] {\texttt{xsq\_w2}} (add1); 
    \draw[->] (mul3) -| node[midway,below] {\texttt{x\_w1}} (add1);

    % Adder + w0
    \node[circop,right=1.5cm of add1,fill=green!20] (add2) {$+$};
    \node [above of=add2, yshift=0.5cm] (w0) {\texttt{w0}};
    \draw[->] (add1) -- (add2);
    \draw[->] (w0) -- (add2);

    % Output
    \draw[->] (add2) -- ++(1,0) node[right] {\texttt{y}};

  
  
\end{tikzpicture}
  \caption{Single cycle implementation of a quadratic function.}
  \label{fig:quad_func}
\end{figure}

\subsection{Quadratic Function with a Multi-Cycle Pipeline }



A single cycle implementation is as follows treating $w_i$ as fixed parameters is:
\begin{systemverilogcode}
module quad_func #(
  parameter int w2 = 0, 
  parameter int w1 = 0, 
  parameter int w0 = 0
) (
  input logic clk,
  input logic int x,
  output logic int y
);
  int xreg;
  always_ff @(posedge clk) begin
    xsq <= xreg * xreg;
    lin_term <= w1 * xreg + w0;
    xreg <= x;
  end
  always_comb begin
    y = w2*xsq + lin_term;
  end
endmodule
\end{systemverilogcode}



\begin{figure}
\centering
\begin{tikzpicture}
    % Input register
    \node (x) {\texttt{x}};
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        right=1cm of x,fill=blue!10] (xreg) {};
    \draw[->] (x) -- (xreg.input);
    \draw[-] (xreg.output) -- ++(1.3,0) node [midway,above] {\texttt{x\_reg}}
      coordinate (xreg_split);
    \fill (xreg_split) circle (1.5pt);

    % Multiplier for x^2
    \node [circop, right=0.8cm of xreg_split,fill=green!20] (mul1) {$\times$};
    \draw[->] (xreg_split) -- (mul1);
    \draw[->] (xreg_split) -- ++(0,0.5) -| (mul1);

    % Register for xsq
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        right=1cm of mul1,fill=blue!10] (xsqreg) {};
    \draw[->] (mul1) -- (xsqreg.input);


    % Multiplier for w1*x
    \node [circop, below=1cm of mul1,fill=green!20] (mul3) {$\times$};
    \node [below=0.5cm of mul3] (w1) {\texttt{w1}};
    \draw[->] (xreg_split) |- (mul3);
    \draw[->] (w1) -- (mul3);

    % Adder for w1*x + w0
    \node[circop,right=1.3cm of mul3,fill=green!20] (add_lin) {$+$};
    \node [below=1cm of add_lin, yshift=0.5cm] (w0) {\texttt{w0}};
    \draw[->] (mul3) -- (add_lin);
    \draw[->] (w0) -- (add_lin);

    % Register for linear term
    \node[shape=register, draw, minimum width=0.7cm, minimum height=1cm,
        right=1.5cm of add_lin,fill=blue!10] (linreg) {};
    \draw[->] (add_lin) -- (linreg.input);
    

    
    % Multiplier for w2*x^2
    \node [circop, right=1.5cm of xsqreg,fill=green!20] (mul2) {$\times$};
    \node [above of=mul2, yshift=0.5cm] (w2) {\texttt{w2}};
    \draw[->] (xsqreg.output) -- node [midway,above] {\texttt{xsq}} (mul2);
    \draw[->] (w2) -- (mul2);


    % Adder w2*x^2 + lin_term
    \node[circop,right=1.3cm of mul2,fill=green!20] (add1) {$+$};
    \draw[->] (mul2) -- (add1); 
    \draw[->] (linreg.output) -| node[midway,below] {\texttt{lin\_term}} (add1);


    % Output
    \draw[->] (add1) -- ++(1,0) node[right] {\texttt{y}};

  
  
\end{tikzpicture}
  \caption{Two cycle implementation of a quadratic function.}
  \label{fig:quad_func_two}
\end{figure}


  \end{document}

